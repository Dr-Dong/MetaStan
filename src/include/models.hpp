/*
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_BNHM_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_BNHM");
    reader.add_event(43, 43, "end", "model_BNHM");
    return reader;
}

class model_BNHM : public prob_grad {
private:
    int N;
    vector<int> rc;
    vector<int> nc;
    vector<int> rt;
    vector<int> nt;
    vector_d mu_par;
    vector_d theta_par;
    vector_d tau_par;
public:
    model_BNHM(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_BNHM(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_BNHM_namespace::model_BNHM";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            validate_non_negative_index("rc", "N", N);
            context__.validate_dims("data initialization", "rc", "int", context__.to_vec(N));
            validate_non_negative_index("rc", "N", N);
            rc = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("rc");
            pos__ = 0;
            size_t rc_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < rc_limit_0__; ++i_0__) {
                rc[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("nc", "N", N);
            context__.validate_dims("data initialization", "nc", "int", context__.to_vec(N));
            validate_non_negative_index("nc", "N", N);
            nc = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("nc");
            pos__ = 0;
            size_t nc_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < nc_limit_0__; ++i_0__) {
                nc[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("rt", "N", N);
            context__.validate_dims("data initialization", "rt", "int", context__.to_vec(N));
            validate_non_negative_index("rt", "N", N);
            rt = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("rt");
            pos__ = 0;
            size_t rt_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < rt_limit_0__; ++i_0__) {
                rt[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("nt", "N", N);
            context__.validate_dims("data initialization", "nt", "int", context__.to_vec(N));
            validate_non_negative_index("nt", "N", N);
            nt = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("nt");
            pos__ = 0;
            size_t nt_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < nt_limit_0__; ++i_0__) {
                nt[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("mu_par", "2", 2);
            context__.validate_dims("data initialization", "mu_par", "vector_d", context__.to_vec(2));
            validate_non_negative_index("mu_par", "2", 2);
            mu_par = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            vals_r__ = context__.vals_r("mu_par");
            pos__ = 0;
            size_t mu_par_i_vec_lim__ = 2;
            for (size_t i_vec__ = 0; i_vec__ < mu_par_i_vec_lim__; ++i_vec__) {
                mu_par[i_vec__] = vals_r__[pos__++];
            }
            validate_non_negative_index("theta_par", "2", 2);
            context__.validate_dims("data initialization", "theta_par", "vector_d", context__.to_vec(2));
            validate_non_negative_index("theta_par", "2", 2);
            theta_par = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            vals_r__ = context__.vals_r("theta_par");
            pos__ = 0;
            size_t theta_par_i_vec_lim__ = 2;
            for (size_t i_vec__ = 0; i_vec__ < theta_par_i_vec_lim__; ++i_vec__) {
                theta_par[i_vec__] = vals_r__[pos__++];
            }
            validate_non_negative_index("tau_par", "2", 2);
            context__.validate_dims("data initialization", "tau_par", "vector_d", context__.to_vec(2));
            validate_non_negative_index("tau_par", "2", 2);
            tau_par = vector_d(static_cast<Eigen::VectorXd::Index>(2));
            vals_r__ = context__.vals_r("tau_par");
            pos__ = 0;
            size_t tau_par_i_vec_lim__ = 2;
            for (size_t i_vec__ = 0; i_vec__ < tau_par_i_vec_lim__; ++i_vec__) {
                tau_par[i_vec__] = vals_r__[pos__++];
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"rc[k0__]",rc[k0__],0);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"nc[k0__]",nc[k0__],1);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"rt[k0__]",rt[k0__],0);
            }
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"nt[k0__]",nt[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("mu", "N", N);
            num_params_r__ += N;
            ++num_params_r__;
            validate_non_negative_index("zeta", "N", N);
            num_params_r__ += N;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_BNHM() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("mu")))
            throw std::runtime_error("variable mu missing");
        vals_r__ = context__.vals_r("mu");
        pos__ = 0U;
        validate_non_negative_index("mu", "N", N);
        context__.validate_dims("initialization", "mu", "vector_d", context__.to_vec(N));
        vector_d mu(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            mu(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu: ") + e.what());
        }

        if (!(context__.contains_r("theta")))
            throw std::runtime_error("variable theta missing");
        vals_r__ = context__.vals_r("theta");
        pos__ = 0U;
        context__.validate_dims("initialization", "theta", "double", context__.to_vec());
        double theta(0);
        theta = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(theta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable theta: ") + e.what());
        }

        if (!(context__.contains_r("zeta")))
            throw std::runtime_error("variable zeta missing");
        vals_r__ = context__.vals_r("zeta");
        pos__ = 0U;
        validate_non_negative_index("zeta", "N", N);
        context__.validate_dims("initialization", "zeta", "vector_d", context__.to_vec(N));
        vector_d zeta(static_cast<Eigen::VectorXd::Index>(N));
        for (int j1__ = 0U; j1__ < N; ++j1__)
            zeta(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(zeta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable zeta: ") + e.what());
        }

        if (!(context__.contains_r("tau")))
            throw std::runtime_error("variable tau missing");
        vals_r__ = context__.vals_r("tau");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau", "double", context__.to_vec());
        double tau(0);
        tau = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,tau);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu;
            (void) mu;  // dummy to suppress unused var warning
            if (jacobian__)
                mu = in__.vector_constrain(N,lp__);
            else
                mu = in__.vector_constrain(N);

            T__ theta;
            (void) theta;  // dummy to suppress unused var warning
            if (jacobian__)
                theta = in__.scalar_constrain(lp__);
            else
                theta = in__.scalar_constrain();

            Eigen::Matrix<T__,Eigen::Dynamic,1>  zeta;
            (void) zeta;  // dummy to suppress unused var warning
            if (jacobian__)
                zeta = in__.vector_constrain(N,lp__);
            else
                zeta = in__.vector_constrain(N);

            T__ tau;
            (void) tau;  // dummy to suppress unused var warning
            if (jacobian__)
                tau = in__.scalar_lb_constrain(0,lp__);
            else
                tau = in__.scalar_lb_constrain(0);


            // transformed parameters
            validate_non_negative_index("pc", "N", N);
            vector<T__> pc(N);
            stan::math::initialize(pc, DUMMY_VAR__);
            stan::math::fill(pc,DUMMY_VAR__);
            validate_non_negative_index("pt", "N", N);
            vector<T__> pt(N);
            stan::math::initialize(pt, DUMMY_VAR__);
            stan::math::fill(pt,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(pc,i,"pc",1), inv_logit(get_base1(mu,i,"mu",1)));
                stan::math::assign(get_base1_lhs(pt,i,"pt",1), inv_logit(((get_base1(mu,i,"mu",1) + theta) + (get_base1(zeta,i,"zeta",1) * tau))));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pc[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pc" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                if (stan::math::is_uninitialized(pt[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pt" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // model body

            lp_accum__.add(normal_log<propto__>(zeta, 0, 1));
            lp_accum__.add(normal_log<propto__>(mu, get_base1(mu_par,1,"mu_par",1), get_base1(mu_par,2,"mu_par",1)));
            lp_accum__.add(normal_log<propto__>(theta, get_base1(theta_par,1,"theta_par",1), get_base1(theta_par,2,"theta_par",1)));
            lp_accum__.add(normal_log<propto__>(tau, get_base1(tau_par,1,"tau_par",1), get_base1(tau_par,2,"tau_par",1)));
            if (tau < 0) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-normal_ccdf_log(0, get_base1(tau_par,1,"tau_par",1), get_base1(tau_par,2,"tau_par",1)));
            lp_accum__.add(binomial_log<propto__>(rc, nc, pc));
            lp_accum__.add(binomial_log<propto__>(rt, nt, pt));

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("mu");
        names__.push_back("theta");
        names__.push_back("zeta");
        names__.push_back("tau");
        names__.push_back("pc");
        names__.push_back("pt");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_BNHM_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d mu = in__.vector_constrain(N);
        double theta = in__.scalar_constrain();
        vector_d zeta = in__.vector_constrain(N);
        double tau = in__.scalar_lb_constrain(0);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(mu[k_0__]);
            }
        vars__.push_back(theta);
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(zeta[k_0__]);
            }
        vars__.push_back(tau);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            validate_non_negative_index("pc", "N", N);
            vector<double> pc(N, 0.0);
            stan::math::initialize(pc, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pc,DUMMY_VAR__);
            validate_non_negative_index("pt", "N", N);
            vector<double> pt(N, 0.0);
            stan::math::initialize(pt, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(pt,DUMMY_VAR__);


            for (int i = 1; i <= N; ++i) {

                stan::math::assign(get_base1_lhs(pc,i,"pc",1), inv_logit(get_base1(mu,i,"mu",1)));
                stan::math::assign(get_base1_lhs(pt,i,"pt",1), inv_logit(((get_base1(mu,i,"mu",1) + theta) + (get_base1(zeta,i,"zeta",1) * tau))));
            }

            // validate transformed parameters

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pc[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N; ++k_0__) {
            vars__.push_back(pt[k_0__]);
            }

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_BNHM";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "theta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "zeta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pt" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "theta";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "zeta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pc" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "pt" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

}




#endif
